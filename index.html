<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Portfolio | Lisa Voronov</title>
    <style>
        @font-face {
            font-family: 'PP Neue Montreal';
            src: url('PPNeueMontreal-Regular.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }

        body { 
            margin: 0; 
            padding: 0;
            display: flex; 
            height: 100vh; 
            width: 100vw;
            overflow: hidden;
            background: #0D0D0D; 
            font-family: 'PP Neue Montreal', sans-serif; 
        }

        .column { 
            width: 50%; 
            height: 100vh; 
            overflow: hidden; 
            box-sizing: border-box;
        }

        .column::-webkit-scrollbar { 
            display: none; 
        } 

        .item { 
            width: 100%; 
            height: 100vh; 
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0D0D0D; /* Фон, пока грузится фото */
        }

        .item img { 
            width: 100%; 
            height: 100vh; 
            object-fit: cover; 
            display: block; 
            transition: opacity 0.5s ease; 
        }

        .item a {
            display: block;
            width: 100%;
            height: 100%;
        }

        .item a:hover img {
            opacity: 0.6;
        }

        @media (max-width: 768px) {
            .column {
                width: 100%;
                overflow-y: scroll;
            }
            #right {
                display: none;
            }
        }
    </style>
</head>
<body>

    <div id="left" class="column">
        <div class="item"><img src="work1.png" loading="eager" decoding="async"></div>
        <div class="item"><a href="project1.html"><img src="work3.png" loading="eager" decoding="async"></a></div>
        <div class="item"><a href="project2.html"><img src="work5.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project3.html"><img src="work7.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project4.html"><img src="work9.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project5.html"><img src="work11.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project6.html"><img src="work13.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project7.html"><img src="work15.png" loading="lazy" decoding="async"></a></div>
    </div>

    <div id="right" class="column">
        <div class="item"><a href="project7.html"><img src="work16.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project6.html"><img src="work14.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project5.html"><img src="work12.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project4.html"><img src="work10.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project3.html"><img src="work8.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project2.html"><img src="work6.png" loading="lazy" decoding="async"></a></div>
        <div class="item"><a href="project1.html"><img src="work4.png" loading="eager" decoding="async"></a></div>
        <div class="item"><img src="work2.png" loading="eager" decoding="async"></div>
    </div>

    <script>
        const left = document.getElementById('left');
        const right = document.getElementById('right');
        const itemsCount = left.querySelectorAll('.item').length;
        let currentIndex = 0;
        
        // Состояние анимации (чтобы можно было отменить текущую и начать новую)
        let leftAnim = { id: null };
        let rightAnim = { id: null };

        // Настройки чувствительности скролла
        let scrollAccumulator = 0;
        const scrollThreshold = 200; // Порог срабатывания (еще выше для защиты от случайных скроллов)
        let lastScrollTime = 0;
        let scrollResetTimer = null; // Таймер сброса инерции
        const scrollCooldown = 600; // Пауза для гашения инерции трекпада

        // Отключаем восстановление скролла браузером, чтобы всегда начинать правильно
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }

        // Устанавливаем начальное положение (правая колонка в самом низу)
        window.onload = () => {
            // Проверяем, есть ли параметр p в URL (номер слайда)
            const params = new URLSearchParams(window.location.search);
            const p = parseInt(params.get('p'), 10);

            if (!isNaN(p) && p >= 0 && p < itemsCount) {
                currentIndex = p;
            }

            const vh = window.innerHeight;
            left.scrollTop = currentIndex * vh;
            right.scrollTop = (itemsCount - 1 - currentIndex) * vh;
        };

        // Функция для плавной анимации с возможностью прерывания
        function smoothScrollTo(element, target, duration, animState) {
            // Если анимация уже идет, отменяем её, чтобы начать новую к новой цели
            if (animState.id) cancelAnimationFrame(animState.id);

            const start = element.scrollTop;
            const change = target - start;
            const startTime = performance.now();

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing: easeOutQuart — эффект сильного магнита
                // (быстрый старт, очень медленная и плавная остановка)
                const ease = 1 - Math.pow(1 - progress, 4);

                element.scrollTop = start + change * ease;

                if (progress < 1) {
                    animState.id = requestAnimationFrame(animate);
                } else {
                    animState.id = null;
                }
            }
            animState.id = requestAnimationFrame(animate);
        }

        // Единый обработчик колесика для всего окна
        window.addEventListener('wheel', (e) => {
            e.preventDefault(); // Блокируем стандартный скролл страницы
            
            const now = Date.now();
            const timeSinceLast = now - lastScrollTime;

            // Игнорируем инерцию сразу после переключения (самое важное для устранения "пролетания")
            if (timeSinceLast < scrollCooldown) {
                scrollAccumulator = 0;
                return;
            }

            // Накапливаем импульс скролла
            scrollAccumulator += e.deltaY;
            
            // Сбрасываем накопитель, если скролл прекратился
            clearTimeout(scrollResetTimer);
            scrollResetTimer = setTimeout(() => { scrollAccumulator = 0; }, 200);

            // Если накопили достаточно движения И прошло немного времени с прошлого раза
            if (Math.abs(scrollAccumulator) > scrollThreshold) {
                const direction = scrollAccumulator > 0 ? 1 : -1;

                // Проверка границ
                if ((direction === 1 && currentIndex < itemsCount - 1) || 
                    (direction === -1 && currentIndex > 0)) {
                    
                    currentIndex += direction;

                    const vh = window.innerHeight;
                    
                    // АДАПТИВНАЯ СКОРОСТЬ:
                    // Если скроллим часто (интервал < 1200мс) -> быстро (800мс)
                    // Если спокойно -> плавно и медленно (2000мс)
                    const duration = timeSinceLast < 1200 ? 800 : 2000; 
                    
                    lastScrollTime = now;

                    // Запускаем анимацию (или обновляем цель, если уже едем)
                    smoothScrollTo(left, currentIndex * vh, duration, leftAnim);
                    smoothScrollTo(right, (itemsCount - 1 - currentIndex) * vh, duration, rightAnim);
                }
                
                // Сбрасываем накопитель, чтобы ловить следующий "щелчок" колеса
                scrollAccumulator = 0;
            }

        }, { passive: false });
    </script>
</body>
</html>
